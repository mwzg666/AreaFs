C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\obj\main.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE main.c XSMALL OPTIMIZE(0,SPEED) BROWSE INCDIR(.\Ads1110;.\Flash;.\mcp4
                    -725;.\IIC;.\MwPro;.\Uart;.\Lcd;.\ModBus;.\Probe;.\BSP;.\MwPro) PRINT(.\obj\main.lst) OBJECT(.\obj\main.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include "mcp4725.h"
    3          #include "Lcd.h"
    4          #include "LcdApp.h"
    5          #include "ModBusDev.h"
    6          #include "ModBusHost.h"
    7          #include "system.h"
    8          #include "CalcDoseRate.h"
    9          #include "i2c.h"
   10          #include "uart.h"
   11          #include "EepRom.h"
   12          #include "MwPro.h"
   13          #include "ModBus.h"
   14          #include "PD_Probe.h"
   15          #include "Sensor.h"
   16          #include "cmd.h"
   17          
   18          BYTE code VERSION = 101;  // V1.0.0
   19          
   20          BYTE xdata StrTmp[64] = {0};
   21          BYTE ChannelError[FLOW_METER_CNT] ={0};
   22          
   23          #define Log //((CSampDemoDlg *)theApp.m_pMainWnd)->AddLog
   24          
   25          #define PARAM_SIGN  0x3132
   26          SYS_PARAM xdata SysParam;
   27          RUN_STATUS xdata RunStatus;
   28          PROBE_REGADDR xdata ProbeRegAddr;
   29          
   30          BYTE ProbeSwitch = 0;               //0:GM  1:NaI   2:PD
   31          BYTE ProbeSwitch_State = 0;
   32          
   33          LP_SYSTEM_STTAE SysRunState={0};
   34          BYTE Input_Status = 0;
   35          u16 Eth_InitTim = 0;
   36          bool Eth_Initflag = true;
   37          
   38          u16 SendPDTim = 0;
   39          BYTE SendPDFlag = 0;
   40          
   41          BYTE MP3_StopFlag = 0;
   42          BOOL AlarmConfirm_flag = false;
   43          char Unit[8];
   44          float My_PDDoserate = 0;
   45          float My_Doserate = 0;
   46          
   47          BYTE DevInfo_ShowCnt = 0;
   48          bool DevInfo_Showflag = false;
   49          
   50          
   51          
   52          
   53          alt_u8 g_Output[OUT_IO_COUNT]      = {0,0,0,0};   // 上电绿灯亮 // 
   54          alt_u8 g_OutStatus[OUT_IO_COUNT]   = {0,0,0,0};
   55          
   56          
   57          extern u8  TX1_Cnt;    //发送计数
   58          extern u8  RX1_Cnt;    //接收计数
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 2   

   59          extern bit B_TX1_Busy; //发送忙标志
   60          extern u16 Rx1_Timer;
   61          
   62          extern u8  TX2_Cnt;    //发送计数
   63          extern u8  RX2_Cnt;    //接收计数
   64          extern bit B_TX2_Busy; //发送忙标志
   65          extern u16 Rx2_Timer;
   66          
   67          extern u8  RX3_Cnt;    //接收计数
   68          extern u8  TX3_Cnt;    //发送计数
   69          extern bit B_TX3_Busy; //发送忙标志
   70          extern u16 Rx3_Timer;
   71          
   72          extern u8  RX4_Cnt;    //接收计数
   73          extern u8  TX4_Cnt;    //发送计数
   74          extern bit B_TX4_Busy; //发送忙标志
   75          extern u16 Rx4_Timer;
   76          
   77          
   78          extern u8  xdata RX2_Buffer[]; //接收缓冲
   79          extern u8  xdata RX3_Buffer[]; //接收缓冲
   80          
   81          extern const NH_PARAM NhDef[NH_COUNT];
   82          extern char code UnitText[3][8];
   83          extern WORD xdata ScaleBuf[SCALE_NUM];
   84          
   85          
   86          void DebugMsg(char *msg)
   87          {
   88   1          BYTE len = (BYTE)strlen(msg);
   89   1          //Uart1Send((BYTE *)msg,len);
   90   1      }
   91          
   92          void DebugInt(int msg)
   93          {
   94   1          memset(StrTmp,0,64);
   95   1          sprintf(StrTmp,"%x\r\n",msg);
   96   1          DebugMsg(StrTmp);
   97   1      }
   98          
   99          void DumpCmd(BYTE *dat, BYTE len)
  100          {
  101   1          BYTE i;
  102   1          memset(StrTmp,0,64);
  103   1          for (i=0;i<len;i++)
  104   1          {
  105   2              if (strlen(StrTmp) >= 60)
  106   2              {
  107   3                  break;
  108   3              }
  109   2              sprintf(&StrTmp[i*3], "%02X ", dat[i]);
  110   2          }
  111   1          sprintf(&StrTmp[i*3], "\r\n");
  112   1          DebugMsg(StrTmp);
  113   1      }
  114          
  115          void Error()
  116          {
  117   1          while(1)
  118   1          {
  119   2              RUN_LED(1);
  120   2              delay_ms(50);
  121   2              RUN_LED(0);
  122   2              delay_ms(50);
  123   2          }
  124   1          
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 3   

  125   1      }
  126          
  127          void IoInit()
  128          {
  129   1          EAXFR = 1;
  130   1          WTST = 0;  //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
  131   1      
  132   1          P0M1 = 0x50;      P0M0 = 0x00;  // P0.0 P0.1 P0.4 推挽输出
  133   1          P1M1 = 0x00;      P1M0 = 0x00;   //设置为准双向口
  134   1          P2M1 = 0x00;      P2M0 = 0x0F;   // P2.2 推挽输出       P2M0 = 0xCF
  135   1          P3M1 = 0x24;      P3M0 = 0x18;   //设置为准双向口
  136   1          P4M1 = 0x00;      P4M0 = 0x01;   //设置为准双向口          P4M0 = 0x1F
  137   1          P5M1 = 0x00;      P5M0 = 0x05;   //设置为准双向口
  138   1          P6M1 = 0xF0;      P6M0 = 0x00;   //设置为准双向口
  139   1          P7M1 = 0x00;      P7M0 = 0x01;   //设置为准双向口          P7M0 = 0x1D;
  140   1      }
  141          
  142          //网络模块初始化
  143          void ETH_Init()
  144          { 
  145   1          ES0_M(1);
  146   1          delay_ms(200);
  147   1          ES0_M(0);
  148   1      
  149   1          //网络参数。   
  150   1          //STA 
  151   1          Uart3Send("at+Netmode=2\r\n",14);                   // sta模式
  152   1          delay_ms(100);
  153   1          Uart3Send("at+LANIp=192.168.16.254\r\n",25);        // 设备ip
  154   1          delay_ms(100);
  155   1          Uart3Send("at+LANIpMask=255.255.255.0\r\n",28);     // 设备网关
  156   1          delay_ms(100);
  157   1          Uart3Send("at+Dhcpd=0\r\n",12);     
  158   1          delay_ms(100);
  159   1          Uart3Send("at+STASsid=TheOne\r\n",19);              // 远端名称
  160   1          delay_ms(100);
  161   1          Uart3Send("at+STAPasswd=20251111\r\n",23);          // 远端密码
  162   1          delay_ms(100);
  163   1          Uart3Send("at+STAEncType=6\r\n",17);                // 密码保护方式
  164   1          delay_ms(100);
  165   1          Uart3Send("at+Dhcpc=1\r\n",12);                     // 动态匹配IP
  166   1          delay_ms(100);
  167   1      
  168   1          //静态IP
  169   1      //    Uart3Send("at+WANIp=192.168.0.49\r\n",23);
  170   1      //    delay_ms(50);
  171   1      //    Uart3Send("at+WANIpMask=255.255.255.0\r\n",28);
  172   1      //    delay_ms(50);
  173   1      //    Uart3Send("at+SGw=192.168.0.1\r\n",20);
  174   1      //    delay_ms(50);
  175   1      //    Uart3Send("at+SDnsF=114.114.144.114\r\n",27);
  176   1      //    delay_ms(50);
  177   1      
  178   1          //AP
  179   1      //    Uart3Send("at+Netmode=3\r\n",14);
  180   1      //    delay_ms(100);
  181   1      //    Uart3Send("at+Dhcpd=1\r\n",12);
  182   1      //    delay_ms(100);
  183   1      //    Uart3Send("at+LANIp=192.168.10.1\r\n",23);
  184   1      //    delay_ms(100);
  185   1      //    Uart3Send("at+LANIpMask=255.255.255.0\r\n",28);
  186   1      //    delay_ms(100);
  187   1      //    Uart3Send("at+DhcpdIpStart=192.168.10.100\r\n",32);
  188   1      //    delay_ms(100);
  189   1      //    //Uart3Send("at+DhcpdMask=255.255.255.0\r\n",28);
  190   1      //    //delay_ms(200);
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 4   

  191   1      //    Uart3Send("at+DhcpdIpStop=192.168.10.250\r\n",31);
  192   1      //    delay_ms(100);
  193   1      //    Uart3Send("at+DhcpdTime=86400\r\n",20);
  194   1      //    delay_ms(100);
  195   1      //    Uart3Send("at+APEncType=6\r\n",16);
  196   1      //    delay_ms(100);
  197   1      //    Uart3Send("at+APSsid=HLKWIFI\r\n",19);
  198   1      //    delay_ms(100);
  199   1      //    Uart3Send("at+APPasswd=12345678\r\n",22);
  200   1      //    delay_ms(100);
  201   1          
  202   1          //模块串口 0 配置指令
  203   1          Uart3Send("at+NProType0=2\r\n",16);
  204   1          delay_ms(100);
  205   1          Uart3Send("at+NDomain0=192.168.74.204\r\n",28);     // 主机IP
  206   1          delay_ms(100);
  207   1          Uart3Send("at+NRPort0=8020\r\n",17);                // 远端端口
  208   1          delay_ms(100);
  209   1          Uart3Send("at+NLPort0=8080\r\n",17);                // 设备端口
  210   1          delay_ms(100);
  211   1          Uart3Send("at+NTcpTo0=0\r\n",14);
  212   1          delay_ms(100);
  213   1          CLR_WDT = 1;  // 喂狗
  214   1          Uart3Send("at+NProType1=0\r\n",16);
  215   1          delay_ms(100);
  216   1          Uart3Send("at+SBaud0=9600\r\n",16);
  217   1          delay_ms(100);
  218   1          Uart3Send("at+SWidth0=8\r\n",14);
  219   1          delay_ms(100);
  220   1          Uart3Send("at+SPari0=0\r\n",13);
  221   1          delay_ms(100);
  222   1          Uart3Send("at+SPari1=0\r\n",13);
  223   1          delay_ms(100);
  224   1          Uart3Send("at+SStop0=1\r\n",13);
  225   1          delay_ms(100);
  226   1          //保存，提交指令。
  227   1          Uart3Send("at+Save=1\r\n",11);
  228   1          delay_ms(100);
  229   1          Uart3Send("at+Apply=1\r\n",12);
  230   1          delay_ms(100);    
  231   1          Uart3Send("at+Reboot=1\r\n",13);
  232   1          delay_ms(100);
  233   1      }
  234          
  235          //语音模块初始化
  236          void LX_MP3_Init(void)
  237          {
  238   1          A1(0);
  239   1          A2(0);
  240   1          A3(0);
  241   1          A4(0);
  242   1          A5(0);
  243   1          A6(0);
  244   1          A7(0);
  245   1          A8(0);
  246   1          A9(0);
  247   1          PAUSE_M(0);
  248   1          
  249   1      }
  250          
  251          //探头类型选择
  252          void ProbeSelect()      
  253          {
  254   1          if((D1()&&D2()))
  255   1          {
  256   2              ProbeSwitch = 0;
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 5   

  257   2          }
  258   1          else
  259   1          {
  260   2              if(!D1())
  261   2              {
  262   3                  ProbeSwitch = 1;
  263   3              }
  264   2              else if(!D2())
  265   2              {
  266   3                  ProbeSwitch = 2;
  267   3              }
  268   2          }
  269   1          if(ProbeSwitch_State != ProbeSwitch)
  270   1          { 
  271   2              DevParamDef();
  272   2              SendCps();
  273   2              if(ProbeSwitch != 2)
  274   2              {
  275   3                  MCP4725_OutVol(MCP4725_S1_ADDR,(char *)SysParam.Lp_Param.s_SysParam.yuzhi1);
  276   3              }
  277   2             
  278   2              ProbeSwitch_State = ProbeSwitch;
  279   2          }
  280   1          
  281   1         
  282   1      }
  283          
  284          void OutCtl(alt_u8 id, alt_u8 st)
  285          {
  286   1          if (g_OutStatus[id] == st)
  287   1          {
  288   2              return;
  289   2          }
  290   1      
  291   1          g_OutStatus[id] = st;
  292   1          
  293   1          switch(id)
  294   1          {   
  295   2              case LIGHT_GREEN: 
  296   2              {
  297   3                  (st)? GRE_LIGHT(1):GRE_LIGHT(0);
  298   3                  break;
  299   3              }
  300   2      
  301   2              case LIGHT_BLUE: 
  302   2              {
  303   3                  (st)? BLU_LIGHT(1)   :BLU_LIGHT(0); 
  304   3                  break;
  305   3              }
  306   2              
  307   2              case LIGHT_RED:      
  308   2              {
  309   3                  (st)? RED_LIGHT(1) : RED_LIGHT(0);
  310   3                  break;
  311   3              }
  312   2      
  313   2      
  314   2              case ALARM_SOUND:   //蜂鸣器
  315   2              {
  316   3                  (st)? ALARM(1) : ALARM(0);       
  317   3                  break;
  318   3              }
  319   2          }
  320   1      
  321   1          
  322   1      }
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 6   

  323          
  324          void OutFlash(alt_u8 id)
  325          {
  326   1          static alt_u16 OutTimer[OUT_IO_COUNT] = {0,0,0,0};
  327   1          if (OutTimer[id] ++ > LED_FLASH_TIME/10)
  328   1          {
  329   2              OutTimer[id] = 0;
  330   2              if (g_OutStatus[id] == 1)
  331   2              {
  332   3                  OutCtl(id, 0);
  333   3              }
  334   2              else
  335   2              {
  336   3                  OutCtl(id, 1);
  337   3              }
  338   2          }
  339   1      }
  340          
  341          void IoCtlTask()
  342          {
  343   1          alt_u8 i;
  344   1          for (i=0;i<OUT_IO_COUNT;i++)
  345   1          {
  346   2              if (g_Output[i] == 2)
  347   2              {
  348   3                  OutFlash(i);
  349   3              }
  350   2              else
  351   2              {
  352   3                  OutCtl(i, g_Output[i]);
  353   3              }
  354   2          }
  355   1      }
  356          
  357          // 板载指示灯
  358          void RunLed(u16 dt)
  359          {   
  360   1          static u16 tm = 0;
  361   1          u16 to = 3000;
  362   1          tm += dt;
  363   1      
  364   1          if (tm > to)
  365   1          {
  366   2              tm = 0;
  367   2              RUN_LED(0);
  368   2          }
  369   1          else if (tm > (to-100))
  370   1          {
  371   2              RUN_LED(1);
  372   2          }
  373   1      }
  374          
  375          
  376          
  377          void Task1s()
  378          {
  379   1          static BYTE tm = 0;
  380   1      
  381   1          //CLR_WDT = 1;  // 喂狗
  382   1          
  383   1          tm++;
  384   1          if((tm == 3))
  385   1          {
  386   2               if(ProbeSwitch == 2)
  387   2               {
  388   3                  WritePD_Thr();       
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 7   

  389   3                  WritePD_fix();
  390   3               }
  391   2          }
  392   1      
  393   1          if((tm == 6))
  394   1          {
  395   2               if(ProbeSwitch == 2)
  396   2               {
  397   3                  SendReadPD();       //读中子探头的数据
  398   3               }
  399   2              //GetRetCode();
  400   2          }
  401   1          
  402   1          if(tm == 9)
  403   1          {
  404   2              DevRun();
  405   2          }
  406   1          
  407   1          if(tm == 10)
  408   1          {
  409   2              CLR_WDT = 1;  // 喂狗
  410   2              SysRunState.isCanReadSensor = 1;      
  411   2              tm = 0;
  412   2              Eth_InitTim ++;
  413   2              if(Eth_InitTim > 8)
  414   2              {
  415   3                  Eth_InitTim = 0;
  416   3                  if(!Eth_Initflag)
  417   3                  {
  418   4                      return;
  419   4                  }
  420   3                  
  421   3                  ETH_Init();
  422   3                  Eth_Initflag = false;
  423   3              }
  424   2      
  425   2          } 
  426   1      }
  427          
  428          
  429          void CheckDevInfo()
  430          {
  431   1          if(DevInfo_Showflag)
  432   1          {
  433   2              ShowModule(MP_ID_END,REG_DEV_ID); 
  434   2              ShowModule(MP_VER_END,REG_DEV_VER); 
  435   2          }
  436   1          else
  437   1          {
  438   2              HideModule(MP_ID_END);
  439   2              HideModule(MP_VER_END);
  440   2          }
  441   1          
  442   1      }
  443          
  444          
  445          //报警确认按钮，长按关机，短按取消报警声
  446          void AlmConfirm()
  447          {
  448   1          if((SysRunState.keydownFlag == 1)&&(POWER_LOCK()))
  449   1          {
  450   2              if(SysRunState.keydownTime < 100)//按键时间超过1s，不超过4秒都认为短按
  451   2              {
  452   3                  //SysRunState.keyValue = 1; 
  453   3                  g_Output[ALARM_SOUND] = 0; 
  454   3                  if(MP3_StopFlag)
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 8   

  455   3                  {
  456   4                  
  457   4                      if(!AlarmConfirm_flag)
  458   4                      {
  459   5                          StopMP3(MP3_2);
  460   5                          StopMP3(MP3_3);
  461   5                          StartMP3(MP3_STOP);
  462   5                      }
  463   4                  }
  464   3                  AlarmConfirm_flag = true;
  465   3                  //StopAlmLight();
  466   3              }
  467   2              else if(SysRunState.keydownTime < 400)//按键时间超过1s，不超过4秒都认为短按
  468   2             {
  469   3                   if(!DevInfo_Showflag)
  470   3                   {
  471   4                       //DevInfo_ShowCnt = 1;
  472   4                       DevInfo_Showflag = true;
  473   4                   }
  474   3                   else
  475   3                   {
  476   4                       //DevInfo_ShowCnt = 1;
  477   4                       DevInfo_Showflag = false;
  478   4                   }
  479   3                   CheckDevInfo();
  480   3              }
  481   2      
  482   2             SysRunState.keydownFlag = 0;
  483   2             SysRunState.keydownTime = 0;
  484   2         }
  485   1      }
  486          
  487          
  488          void TimerTask()
  489          {
  490   1          u16 delta = 0;
  491   1          static u16 Time1s = 0;
  492   1          
  493   1          if (Timer0Cnt)
  494   1          {
  495   2              delta = Timer0Cnt * 10;
  496   2              Timer0Cnt = 0;
  497   2      
  498   2              if (RX1_Cnt > 0)
  499   2             {
  500   3                 Rx1_Timer += delta;
  501   3             }
  502   2      
  503   2              if (RX2_Cnt > 0)
  504   2              {
  505   3                  Rx2_Timer += delta;
  506   3              }
  507   2      
  508   2              if(RX3_Cnt > 0)
  509   2              {
  510   3                  Rx3_Timer += delta;
  511   3              }
  512   2              
  513   2              if(RX4_Cnt > 0)
  514   2              {
  515   3                  Rx4_Timer += delta;
  516   3              }
  517   2              
  518   2              SendPDTim += delta;
  519   2              if(SendPDTim > 400)
  520   2              {
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 9   

  521   3                  SendPDTim = 0;
  522   3                  SendPDFlag = 1;
  523   3              }
  524   2              
  525   2              RunLed(delta);
  526   2              IoCtlTask();
  527   2              ProbeSelect();
  528   2              //CheckDevInfo();
  529   2              //Cps_Check();
  530   2              Time1s += delta;
  531   2              if (Time1s >= 100)
  532   2              {
  533   3                  Time1s = 0;
  534   3                  Task1s();
  535   3              }
  536   2          }
  537   1      }
  538          
  539          void Delay(WORD ms)
  540          {
  541   1          WORD t = 1000;
  542   1          while(ms--)
  543   1          {
  544   2              for (t=0;t<1000;t++) ;
  545   2          }
  546   1      }
  547          
  548          void Delayms(WORD ms)    //@11.0592MHz
  549          {
  550   1          unsigned long edata i;
  551   1          while(ms--)
  552   1          {
  553   2              _nop_();
  554   2              _nop_();
  555   2              i = 2763UL;
  556   2              while (i) i--;
  557   2          }
  558   1      }
  559          
  560          void delay_ms(unsigned int ms)
  561          {
  562   1          unsigned int i;
  563   1          do{
  564   2              i = MAIN_Fosc / 6030;
  565   2              while(--i);
  566   2          }while(--ms);
  567   1      }
  568          
  569          
  570          WORD ParamCheck(BYTE *buf, WORD len)
  571          {
  572   1          WORD dwSum = 0;
  573   1          WORD i;
  574   1      
  575   1          for (i = 0; i < len; i++)
  576   1          {
  577   2              dwSum += buf[i];
  578   2          }
  579   1      
  580   1          return dwSum;
  581   1      }
  582          
  583          void ReadParam()
  584          {
  585   1          EEPROM_read(0, (BYTE *)&SysParam, sizeof(SYS_PARAM));
  586   1          if ((SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2)))
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 10  

  587   1          {
  588   2              GeneralParam();
  589   2              DevParamDef();
  590   2              memcpy(SysParam.VerSion,DEV_VER,6);
  591   2              WriteParam();
  592   2          }
  593   1      }
  594          
  595          void WriteParam()
  596          {
  597   1          EA = 0;    
  598   1          
  599   1          EEPROM_SectorErase(0);
  600   1          EEPROM_SectorErase(512);
  601   1          SysParam.Sum = ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2);
  602   1          if (!EEPROM_write(0, (BYTE *)&SysParam, sizeof(SYS_PARAM)))
  603   1          {
  604   2              Error();
  605   2          }
  606   1      
  607   1          EA = 1;     //打开总中断
  608   1      }
  609          
  610          
  611          void GetInput()
  612          {
  613   1          if(POWER_LOCK() == 0)
  614   1          {
  615   2              delay_ms(30);
  616   2              while(POWER_LOCK() == 0)
  617   2              {
  618   3                  SysRunState.keydownFlag = 1; 
  619   3                  if(SysRunState.keydownTime >= 400)//超过4秒,长按，关机
  620   3                  {
  621   4                      SysRunState.keydownFlag = 0;
  622   4                      SysRunState.keydownTime = 0;
  623   4                      PowerOff();
  624   4                  }
  625   3      //             else if((SysRunState.keydownTime > 100)&&(SysRunState.keydownTime < 400)&&(DevInfo_ShowCnt
             - == 0))//按键时间超过1s，不超过4秒都认为短按
  626   3      //            {
  627   3      //                if(!DevInfo_Showflag)
  628   3      //                {
  629   3      //                    DevInfo_ShowCnt = 1;
  630   3      //                    DevInfo_Showflag = true;
  631   3      //                }
  632   3      //                else
  633   3      //                {
  634   3      //                    DevInfo_ShowCnt = 1;
  635   3      //                    DevInfo_Showflag = false;
  636   3      //                }
  637   3      //                CheckDevInfo();
  638   3      //            }
  639   3              }
  640   2              
  641   2              //DevInfo_ShowCnt = 0;
  642   2              AlmConfirm();
  643   2          }
  644   1      }
  645          
  646          
  647          void PowerOff()
  648          {
  649   1          RED_LIGHT(0);  // 红灯
  650   1          GRE_LIGHT(0);  // 黄灯
  651   1          BLU_LIGHT(0);  // 蓝灯
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 11  

  652   1          ALARM(0);      // 报警音
  653   1          ShowLight(0);
  654   1          PW_MAIN(0);
  655   1      
  656   1          while(1)
  657   1          {
  658   2              ;
  659   2          }
  660   1      }
  661          
  662          void HndInput()
  663          {
  664   1          #if 0
                   static bool em = false;
                   if(STOP_M() == 0)
                   {
                       delay_ms(10);
                       if (STOP_M() == 0)
                       {
                           if (RunStatus.Running)
                           {
                               StopSamp(false);
                           }
                       }
               
                       if (em == false)
                       {
                           em = true;
                           ShowEmStop(em);
                       }
                   }
                   else
                   {
                       if (em)
                       {
                           em = false;
                           ShowEmStop(em);
                       }
                   }
                   #endif
  692   1      }
  693          
  694          /*
  695          void ReportInput()
  696          {
  697              BYTE PwOff = POWER_OFF;
  698              
  699              if (g_CommIdleTime > 200)
  700              {
  701                  if (g_Key_Confrom)
  702                  {
  703                      g_Key_Confrom = 0;
  704                      SendPcCmd(0, CMD_CERTAINKEY, NULL, 0);
  705                      return;
  706                  }
  707          
  708                  if (g_Key_Power)
  709                  {
  710                      g_Key_Power = 0;
  711                      SendPcCmd(0, CMD_POWER, &PwOff, 1);
  712                      return;
  713                  }
  714          
  715                  #if 0
  716                  if (g_Key_Input)
  717                  {
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 12  

  718                      g_Key_Input = 0;
  719                      SendPcCmd(0, CMD_INPUT, &Input_Status, 1);
  720                  }
  721                  #endif
  722              }
  723          }
  724          */
  725          
  726          void LedInit()
  727          {
  728   1          // 指示灯
  729   1          RED_LIGHT(0);  // 红灯
  730   1          GRE_LIGHT(0);  // 绿灯
  731   1          BLU_LIGHT(0);  // 蓝灯
  732   1          ALARM(0);      // 报警音
  733   1      }
  734          
  735          
  736          void GeneralParam()
  737          {
  738   1          SysParam.Sign     = PARAM_SIGN;
  739   1          RunStatus.Unit = Unit_uSv;
  740   1      
  741   1          SysParam.s_General_Info.Address = 1;
  742   1          memset(&SysParam.s_General_Info.Index,0,32); 
  743   1          memset(&SysParam.s_General_Info.Location,0,32); 
  744   1          memset(&SysParam.s_General_Info.Name,0,32); 
  745   1          sprintf((char*) SysParam.s_General_Info.Name,DEV_NAME);  
  746   1          WriteParam();
  747   1      }
  748          
  749          void DevParamDef()
  750          {
  751   1          BYTE i;
  752   1          switch(ProbeSwitch)
  753   1          {
  754   2              case 0:
  755   2                      memset((void*)&SysParam.Lp_Param,0,sizeof(LP_PARAM));
  756   2                      SysParam.Lp_Param.Sign = 0x4142;
  757   2      
  758   2                      SysParam.Lp_Param.s_Alarm.DosePreAlarm = 300;     //300uSv
  759   2                      SysParam.Lp_Param.s_Alarm.DoseAlarm = 400;        //400uSv
  760   2                      SysParam.Lp_Param.s_Alarm.DoseRatePreAlarm = 300;//300uSv/h
  761   2                      SysParam.Lp_Param.s_Alarm.DoseRateAlarm = 400;//400uSv/h
  762   2      
  763   2                      SysParam.Lp_Param.s_SysParam.Canshu1 = 1;
  764   2                      SysParam.Lp_Param.s_SysParam.Canshu2 = 1;
  765   2      
  766   2                      #ifdef POE_SEN
  767   2                      // 低量程用Co60拟合，最后剂量率要乘Co/Cs比
  768   2                      SysParam.Lp_Param.s_Jiaozhun.DI_A = 0.001749524255754;           // 0.0552364572191522;  
             -                  //a = 1.84773623191768
  769   2                      SysParam.Lp_Param.s_Jiaozhun.DI_B = 0.321361930688732;             // 0.325776472823953; 
             -                    //b = 0.362602496332558
  770   2                      SysParam.Lp_Param.s_Jiaozhun.DI_C = 0.00117277837260376;        // 0.00103232522627559;  
             -                  //c = 5.23843587599517E-05
  771   2                      SysParam.Lp_Param.s_Jiaozhun.DI_D = -4.45221185949912E-06;        // -3.46972129850684E-0
             -6;                //d = 2.02801464142905E-09
  772   2      
  773   2                      SysParam.Lp_Param.s_Jiaozhun.MID_A = 5.1735799060138;    
  774   2                      SysParam.Lp_Param.s_Jiaozhun.MID_B = 0.314778799356561; 
  775   2                      SysParam.Lp_Param.s_Jiaozhun.MID_C = 0.000188389561373155;
  776   2                      SysParam.Lp_Param.s_Jiaozhun.MID_D = -6.40204890256851E-08;
  777   2                      
  778   2                      // Cs137 > 1.2m
  779   2                      SysParam.Lp_Param.s_Jiaozhun.GAO_A = 3.62608397252143;            //684.399049164029; 
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 13  

  780   2                      SysParam.Lp_Param.s_Jiaozhun.GAO_B = 6.3652408143604;            //6.14300026842352; 
  781   2                      SysParam.Lp_Param.s_Jiaozhun.GAO_C = 0.00160225788737462;        //5.3028356929535E-05;  
  782   2                      SysParam.Lp_Param.s_Jiaozhun.GAO_D = -1.72769678770162E-06;        //9.30859286124393E-10
             -;
  783   2                      #else
                               SysParam.Lp_Param.s_Jiaozhun.DI_A = 0.5593;    // 0.56;
                               SysParam.Lp_Param.s_Jiaozhun.DI_B = 0.000119; // 0.00017;
                               SysParam.Lp_Param.s_Jiaozhun.DI_C = 1;
                               SysParam.Lp_Param.s_Jiaozhun.GAO_A = 31.92; // 33.6;
                               SysParam.Lp_Param.s_Jiaozhun.GAO_B = 0.000018;  // 0.000023;
                               SysParam.Lp_Param.s_Jiaozhun.GAO_C = 1;
                               #endif
  791   2                      sprintf((char*)SysParam.Lp_Param.s_SysParam.yuzhi1,"160");
  792   2                      SysParam.Lp_Param.CoCsRate = 1.19;
  793   2      
  794   2                      //memcpy((char *)&SysParam.Lp_Param.NhParam, (char *)&NhDef, sizeof(NH_PARAM)*NH_COUNT);
  795   2      
  796   2                      for (i=0;i<FIX_COUNT;i++)
  797   2                      {
  798   3                          SysParam.Lp_Param.Fix[i] = 1.0;
  799   3                      }
  800   2                      break;
  801   2                      
  802   2              case 1: 
  803   2                      memset((void*)&SysParam.Lp_Param,0,sizeof(LP_PARAM));
  804   2                      SysParam.Lp_Param.Sign = 0x4142;
  805   2      
  806   2                      SysParam.Lp_Param.s_Alarm.DosePreAlarm = 300;       //300uSv
  807   2                      SysParam.Lp_Param.s_Alarm.DoseAlarm = 400;          //400uSv
  808   2                      SysParam.Lp_Param.s_Alarm.DoseRatePreAlarm = 30;    //30uSv/h
  809   2                      SysParam.Lp_Param.s_Alarm.DoseRateAlarm = 40;       //40uSv/h
  810   2      
  811   2                      SysParam.Lp_Param.s_SysParam.Canshu1 = 1;
  812   2                      SysParam.Lp_Param.s_SysParam.Canshu2 = 1;
  813   2      
  814   2                      #ifdef POE_SEN
  815   2                      // 低量程用Co60拟合，最后剂量率要乘Co/Cs比
  816   2                      SysParam.Lp_Param.s_Jiaozhun.DI_A = -0.119135107108512;    
  817   2                      SysParam.Lp_Param.s_Jiaozhun.DI_B = 0.406688356856999; 
  818   2                      SysParam.Lp_Param.s_Jiaozhun.DI_C = -0.000795882360575705;
  819   2                      SysParam.Lp_Param.s_Jiaozhun.DI_D = 8.30493670182536E-06;
  820   2      
  821   2                      SysParam.Lp_Param.s_Jiaozhun.MID_A = 25.2437957332788;    
  822   2                      SysParam.Lp_Param.s_Jiaozhun.MID_B = 0.352560222117065; 
  823   2                      SysParam.Lp_Param.s_Jiaozhun.MID_C = 6.84378068779986E-05;
  824   2                      SysParam.Lp_Param.s_Jiaozhun.MID_D = 0;
  825   2                      
  826   2                      // Cs137 > 1.2m
  827   2                      SysParam.Lp_Param.s_Jiaozhun.GAO_A = -32435.201473664; 
  828   2                      SysParam.Lp_Param.s_Jiaozhun.GAO_B = 35.1613941353375; 
  829   2                      SysParam.Lp_Param.s_Jiaozhun.GAO_C = -6.81597532235814E-4;  
  830   2                      SysParam.Lp_Param.s_Jiaozhun.GAO_D = 2.46287003496529E-08;
  831   2                      #else
                               SysParam.Lp_Param.s_Jiaozhun.DI_A = 0.5593;    // 0.56;
                               SysParam.Lp_Param.s_Jiaozhun.DI_B = 0.000119; // 0.00017;
                               SysParam.Lp_Param.s_Jiaozhun.DI_C = 1;
                               SysParam.Lp_Param.s_Jiaozhun.GAO_A = 31.92; // 33.6;
                               SysParam.Lp_Param.s_Jiaozhun.GAO_B = 0.000018;  // 0.000023;
                               SysParam.Lp_Param.s_Jiaozhun.GAO_C = 1;
                               #endif
  839   2                      sprintf((char*)SysParam.Lp_Param.s_SysParam.yuzhi1,"140");
  840   2      
  841   2                      SysParam.Lp_Param.CoCsRate = 1.19;
  842   2                      
  843   2                      #ifdef P2P_NH
                               memcpy((char *)&SysParam.Lp_Param.NhParam, (char *)&NhDef, sizeof(NH_PARAM)*NH_COUNT);
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 14  

                               #endif
  846   2                      
  847   2                      for (i=0;i<FIX_COUNT;i++) //NaI分段乘的系数     1,2：0.67；3:1.22；4:1；5:0.87；6:1.83；7
             -:1.8；8:1；9:1.12
  848   2                      {
  849   3                          SysParam.Lp_Param.Fix[i] = 1.0;
  850   3                      }
  851   2                      break;
  852   2              case 2: 
  853   2                      SysParam.Pd_param.Address = PD_MODBUS_ADDR;
  854   2                      SysParam.Pd_param.s_Alarm.DosePreAlarm = 300;     //300uSv
  855   2                      SysParam.Pd_param.s_Alarm.DoseAlarm = 400;        //400uSv
  856   2                      SysParam.Pd_param.s_Alarm.DoseRatePreAlarm = 300;//300uSv/h
  857   2                      SysParam.Pd_param.s_Alarm.DoseRateAlarm = 400;    //400uSv/h
  858   2                      SysParam.Pd_param.s_Thr.Det_Thr[0] = 255-25;
  859   2                      SysParam.Pd_param.s_Thr.Det_Thr[1] = 10;
  860   2                      SysParam.Pd_param.s_Thr.Det_Thr[2] = 150;
  861   2                      SysParam.Pd_param.s_Thr.AnalogChannel = 0;
  862   2                      for(i = 0;i<PD_FIXNUM;i++)
  863   2                      {
  864   3                          SysParam.Pd_param.fix[i] = 1.0;
  865   3                      }      
  866   2                      break;
  867   2          }
  868   1          SysParam.Cps_Enable = 0;
  869   1          SysParam.Cps_Check = 0;
  870   1      
  871   1          WriteParam();
  872   1      
  873   1      }
  874          
  875          void SaveParam()
  876          {
  877   1          WriteParam();
  878   1      }
  879          
  880          
  881          void UpdataUI()
  882          {
  883   1      
  884   1          //ShowStatus();
  885   1          ShowIcon(REG_STATUS,0);
  886   1          delay_ms(200);
  887   1          StatusColor(true);
  888   1      }
  889          
  890          void InitLcd()
  891          {   
  892   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  893   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  894   1          ShowLightON();
  895   1          delay_ms(200);
  896   1          HideBorder();
  897   1          delay_ms(200);
  898   1          SendCps();
  899   1          delay_ms(200);
  900   1          ShowCps();
  901   1          delay_ms(200);
  902   1          Cps_Check();
  903   1          delay_ms(200);
  904   1          UpdataUI();    
  905   1          delay_ms(200);
  906   1          ShowIcon(MP_SCALE_END+1,36);
  907   1          delay_ms(200);
  908   1          HideControl();
  909   1          delay_ms(200);
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 15  

  910   1          HideModule(MP_ID_END);
  911   1          delay_ms(200);
  912   1          HideModule(MP_VER_END);
  913   1          //SendParam();
  914   1          //delay_ms(200);
  915   1          //SetBkLight(false);
  916   1          //delay_ms(200);
  917   1          //ShowDevInfo();
  918   1          //delay_ms(200);
  919   1      }
  920          
  921          
  922          //char转Unicode
  923          void Char2Unicode(char *buff,BYTE len)
  924          {
  925   1          BYTE i = 0;
  926   1          WORD dat = 0;
  927   1          for(i = 0;i<len;i++)
  928   1          {
  929   2              RunInfo.DoseRate[i] = (dat|buff[i]);
  930   2          }
  931   1      }
  932          
  933          //获取剂量率等数据
  934          void GetDoseRate()
  935          {
  936   1          char drbuff[5] = {0};
  937   1          static WORD time = 0;
  938   1      
  939   1          switch(ProbeSwitch)
  940   1          {
  941   2              case 0:
  942   2              case 1: 
  943   2                      #if 0
                               time++;
                               if(time < 30)
                               {
                                   SysRunState.s_DoseMSG.DoseRate = 2.00; 
                               }
                               else if(time < 60)
                               {
                                   SysRunState.s_DoseMSG.DoseRate = 1386.8;
                                  
                               } 
                               if(time > 60)
                               {
                                   time = 0;
                               } 
                               CalcAlarmState(&SysRunState);
                               My_Doserate = SysRunState.s_DoseMSG.DoseRate;
                               //printf("DoseRate1 = %f\r\n",SysRunState.s_DoseMSG.DoseRate);
                               Set_LP_DoseRateUnit(); 
                               #endif
  963   2                      RunStatus.DoseRate = My_Doserate;               
  964   2                      break;
  965   2              case 2: RunStatus.DoseRate = My_PDDoserate;     // 模拟
  966   2                      break;
  967   2          }
  968   1          if(RunStatus.DoseRate < 10)
  969   1          {
  970   2              sprintf((char *)drbuff,"%.3f", RunStatus.DoseRate);
  971   2          }
  972   1          else if(RunStatus.DoseRate < 100)
  973   1          {
  974   2              sprintf((char *)drbuff,"%.2f", RunStatus.DoseRate);
  975   2          }
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 16  

  976   1          else if(RunStatus.DoseRate == 100)
  977   1          {
  978   2              
  979   2              sprintf((char *)drbuff,"%.1f", RunStatus.DoseRate);
  980   2          }
  981   1          Char2Unicode(drbuff,5);
  982   1          
  983   1          memset(RunInfo.Unit,0,8);
  984   1          //sprintf(Unit, UnitText[RunStatus.Unit]);
  985   1          sprintf(RunInfo.Unit, UnitText[RunStatus.Unit]);
  986   1          LcdCmd(LCD_CMD_WRITE, REG_SCALE_UNIT, (BYTE *)RunInfo.Unit,8);
  987   1      }
  988          
  989          //显示剂量率和刻度指针
  990          void CheckDoseRate()
  991          {
  992   1          WORD deg = 0,i = 0;
  993   1          WORD buf[SCALE_NUM];
  994   1          if(RunStatus.DoseRate <= 10)
  995   1          {
  996   2              ShowVal(ScaleBuf);
  997   2              deg = RunStatus.DoseRate * 10;
  998   2          }
  999   1         else if(RunStatus.DoseRate <= 100)
 1000   1          {
 1001   2              buf[0] = SPIN_SCALE0_VAL;
 1002   2              for(i = 0;i < SCALE_NUM-1;i++)
 1003   2              {
 1004   3                  buf[i+1] = buf[i] + 10;
 1005   3              }
 1006   2              ShowVal((WORD *)buf);
 1007   2              deg = RunStatus.DoseRate;
 1008   2          }
 1009   1      //    else if(RunStatus.DoseRate <= 1000)
 1010   1      //    {
 1011   1      //        buf[0] = SPIN_SCALE10_VAL*5;
 1012   1      //        for(i = 0;i < SCALE_NUM-1;i++)
 1013   1      //        {
 1014   1      //            buf[i+1] = buf[i] + 50;
 1015   1      //        }        
 1016   1      //        ShowVal((WORD *)buf);
 1017   1      //        deg = (RunStatus.DoseRate-500)/5;
 1018   1      //
 1019   1      //       
 1020   1      //    }
 1021   1          ShowSpin(deg);
 1022   1      }
 1023          
 1024          
 1025          //语音模块播放
 1026          void StartMP3(BYTE id)
 1027          {
 1028   1          switch(id)
 1029   1          {
 1030   2              case MP3_1: A1(1);delay_ms(100);break;   
 1031   2      
 1032   2              case MP3_2: A2(1);delay_ms(100);break;   
 1033   2      
 1034   2              case MP3_3: A3(1);delay_ms(100);break;   
 1035   2      
 1036   2              case MP3_4: A4(1);delay_ms(100);break;   
 1037   2      
 1038   2              case MP3_5: A5(1);delay_ms(100);break;   
 1039   2      
 1040   2              case MP3_6: A6(1);delay_ms(100);break;   
 1041   2      
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 17  

 1042   2              case MP3_7: A7(1);delay_ms(100);break;   
 1043   2      
 1044   2              case MP3_8: A8(1);delay_ms(100);break;   
 1045   2      
 1046   2              case MP3_9: A9(1);delay_ms(100);break;   
 1047   2      
 1048   2              case MP3_STOP: PAUSE_M(1);delay_ms(200);  PAUSE_M(0);      break;
 1049   2          }
 1050   1      }
 1051          
 1052          
 1053          //语音模块停止播放
 1054          void StopMP3(BYTE id)
 1055          {
 1056   1          switch(id)
 1057   1          {
 1058   2              case MP3_1: A1(0);delay_ms(100);break;
 1059   2      
 1060   2              case MP3_2: A2(0);delay_ms(100);break;
 1061   2      
 1062   2              case MP3_3: A3(0);delay_ms(100);break;
 1063   2      
 1064   2              case MP3_4: A4(0);delay_ms(100);break;
 1065   2      
 1066   2              case MP3_5: A5(0);delay_ms(100);break;
 1067   2      
 1068   2              case MP3_6: A6(0);delay_ms(100);break;
 1069   2      
 1070   2              case MP3_7: A7(0);delay_ms(100);break;
 1071   2      
 1072   2              case MP3_8: A8(0);delay_ms(100);break;
 1073   2      
 1074   2              case MP3_9: A9(0);delay_ms(100);break;
 1075   2      
 1076   2              case MP3_STOP: PAUSE_M(0);     break;
 1077   2      
 1078   2          }
 1079   1      
 1080   1      }
 1081          
 1082          //停止声光报警
 1083          void StopAlmLight()
 1084          {
 1085   1          g_Output[LIGHT_GREEN] = 0;
 1086   1          g_Output[LIGHT_RED] = 0;
 1087   1          g_Output[ALARM_SOUND] = 0; 
 1088   1      
 1089   1          HideBorder();
 1090   1          StopMP3(MP3_2);
 1091   1          StopMP3(MP3_3);
 1092   1      
 1093   1          if(MP3_StopFlag)
 1094   1          {
 1095   2              if(!AlarmConfirm_flag)
 1096   2              {
 1097   3                  StartMP3(MP3_STOP);
 1098   3              }
 1099   2              MP3_StopFlag = 0;
 1100   2          }
 1101   1          AlarmConfirm_flag = false;
 1102   1      }
 1103          
 1104          //报警情况获取
 1105          void AbnorAlarm()
 1106          {   
 1107   1          bool HaveAlarm = false;
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 18  

 1108   1          
 1109   1          if((DoseRateAlarm == ALM_DOSERATE_PRE)||(DoseRateAlarm == ALM_DOSE_PRE))
 1110   1          {
 1111   2              HaveAlarm = true;
 1112   2              RunInfo.FsIcon = 1;
 1113   2              ShowIcon(REG_STATUS,1);
 1114   2              g_Output[LIGHT_RED] = 1;
 1115   2              g_Output[LIGHT_GREEN] = 1;
 1116   2              ShowIcon(MP_SCALE_END+1,37);
 1117   2              ShowBorderY();
 1118   2              if(!AlarmConfirm_flag)
 1119   2              {
 1120   3                  StartMP3(MP3_2);
 1121   3              }
 1122   2              StopMP3(MP3_3);
 1123   2      
 1124   2          }
 1125   1          else if((DoseRateAlarm == ALM_DOSERATE_ERROR)||(DoseRateAlarm == ALM_DOSE_ERROR)
 1126   1              ||(DoseRateAlarm == ALM_DOSE_OVER))
 1127   1          {
 1128   2              HaveAlarm = true;
 1129   2              RunInfo.FsIcon = 2;
 1130   2              ShowIcon(REG_STATUS,2);
 1131   2              g_Output[LIGHT_RED] = 1;
 1132   2              g_Output[LIGHT_GREEN] = 0;
 1133   2              ShowIcon(MP_SCALE_END+1,38);
 1134   2              ShowBorderR();
 1135   2              if(!AlarmConfirm_flag)
 1136   2              {
 1137   3                  StartMP3(MP3_3);
 1138   3              }
 1139   2              StopMP3(MP3_2);
 1140   2          }
 1141   1          else
 1142   1          {
 1143   2              HaveAlarm = false;
 1144   2          }
 1145   1          if (HaveAlarm)
 1146   1          {
 1147   2              MP3_StopFlag = 1;
 1148   2              if(!AlarmConfirm_flag)
 1149   2              {
 1150   3                   g_Output[ALARM_SOUND] = 1;
 1151   3              }
 1152   2          }
 1153   1          else
 1154   1          {
 1155   2              RunInfo.FsIcon = 0;
 1156   2              ShowIcon(REG_STATUS,0);
 1157   2              ShowIcon(MP_SCALE_END+1,36);
 1158   2              StopAlmLight();
 1159   2          }
 1160   1      }
 1161          
 1162          void CheckAlarm()
 1163          {
 1164   1          switch(ProbeSwitch)
 1165   1          {
 1166   2              case 0:
 1167   2              case 1: 
 1168   2                      if((SysRunState.s_DoseMSG.State & (1<<7)))
 1169   2                      {
 1170   3                          DoseRateAlarm = ALM_DOSERATE_PRE;
 1171   3                      }
 1172   2                      else if((SysRunState.s_DoseMSG.State & (1<<6)))
 1173   2                      {
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 19  

 1174   3                          DoseRateAlarm = ALM_DOSERATE_ERROR;
 1175   3                      }
 1176   2                      #if 0
                               else if((SysRunState.s_DoseMSG.State & (1<<5)))
                               {
                                   DoseRateAlarm = ALM_DOSE_PRE;
                               }
                               else if((SysRunState.s_DoseMSG.State & (1<<4)))
                               {
                                   DoseRateAlarm = ALM_DOSE_ERROR;
                               }
                               else if((SysRunState.s_DoseMSG.State & (1<<3)))
                               {
                                   DoseRateAlarm = ALM_DOSE_OVER;
                               }
                               #endif
 1190   2                      else
 1191   2                      {
 1192   3                          DoseRateAlarm = ALM_DOSERATE_NOR;
 1193   3                      }
 1194   2                      break;
 1195   2              case 2: 
 1196   2                     //printf("DevSt = %d\r\n",SysParam.Pd_param.s_DoseRate.DevSt);
 1197   2                      if((SysParam.Pd_param.s_DoseRate.DevSt & (1<<7)))
 1198   2                      {
 1199   3                          DoseRateAlarm = ALM_DOSERATE_PRE;
 1200   3                      }
 1201   2                      else if((SysParam.Pd_param.s_DoseRate.DevSt & (1<<6)))
 1202   2                      {
 1203   3                          DoseRateAlarm = ALM_DOSERATE_ERROR;
 1204   3                      }
 1205   2                      #if 0
                               else if((SysParam.Pd_param.s_DoseRate.DevSt & (1<<5)))
                               {
                                   DoseRateAlarm = ALM_DOSE_PRE;
                               }
                               else if((SysParam.Pd_param.s_DoseRate.DevSt & (1<<4)))
                               {
                                   DoseRateAlarm = ALM_DOSE_ERROR;
                               }
                               else if((SysParam.Pd_param.s_DoseRate.DevSt & (1<<3)))
                               {
                                   DoseRateAlarm = ALM_DOSE_OVER;
                               }
                               #endif
 1219   2                      else
 1220   2                      {
 1221   3                          DoseRateAlarm = ALM_DOSERATE_NOR;
 1222   3                      }
 1223   2                      break; 
 1224   2          }
 1225   1      
 1226   1          if (HisAlarm != DoseRateAlarm)
 1227   1          {
 1228   2              // 报警有变化才更新界面
 1229   2              //delay_ms(200);
 1230   2              //ShowStatus();
 1231   2              //delay_ms(200);
 1232   2              StatusColor(false);
 1233   2      
 1234   2              HisAlarm = DoseRateAlarm;
 1235   2          }
 1236   1          AbnorAlarm();
 1237   1      }
 1238          
 1239          // 1秒运行一次
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 20  

 1240          void DevRun()
 1241          {
 1242   1          RunStatus.RunTime ++;
 1243   1          //CPS显示
 1244   1          ShowCps();
 1245   1          
 1246   1          GetDoseRate();
 1247   1          
 1248   1          //刻度盘指针显示
 1249   1          CheckDoseRate();
 1250   1      
 1251   1          // 2. 显示剂量率和状态
 1252   1          ShowDoseRate();
 1253   1          // 3. 显示地址和版本
 1254   1          ShowDevInfo();
 1255   1          // 4. 检查报警状态  
 1256   1          if (RunStatus.RunTime > 5)
 1257   1          {
 1258   2              RunStatus.RunTime = 6;
 1259   2              // 运行时间大于10秒才检测
 1260   2              CheckAlarm();
 1261   2          }
 1262   1      
 1263   1      }
 1264          
 1265          
 1266          void SyncModBusDev()
 1267          {
 1268   1          BYTE i;
 1269   1          //SysParam.Pd_param.Address =  SysParam.s_General_Info.Address;
 1270   1          //ModBusPD_Param.Address = SysParam.Pd_param.Address;
 1271   1          //ModBusPD_Param.Ver = SysParam.Pd_param.Ver;
 1272   1          //sprintf(ModBusAddr.Ver,"V%d.%d.%d", SysParam.Ver/100, SysParam.Ver%100/10, SysParam.Ver%10 );
 1273   1      //    memset(&ModBusPD_Param.s_DoseRate, 0, sizeof(PD_DOSERATE));
 1274   1      //    ModBusPD_Param.s_DoseRate.DoseRate = SysParam.Pd_param.s_DoseRate.DoseRate;
 1275   1      //    ModBusPD_Param.s_DoseRate.DoseTotal = SysParam.Pd_param.s_DoseRate.DoseTotal;
 1276   1      //    ModBusPD_Param.s_DoseRate.DevSt= SysParam.Pd_param.s_DoseRate.DevSt;
 1277   1      //    ModBusPD_Param.s_DoseRate.Cps1 = SysParam.Pd_param.s_DoseRate.Cps1;
 1278   1      //    ModBusPD_Param.s_DoseRate.Cps2 = SysParam.Pd_param.s_DoseRate.Cps2;
 1279   1      //    ModBusPD_Param.s_DoseRate.Cps3 = SysParam.Pd_param.s_DoseRate.Cps3;
 1280   1      
 1281   1          memset(&ModBusPD_Param.s_Alarm, 0, sizeof(PD_ALARM));
 1282   1          ModBusPD_Param.s_Alarm.DoseRatePreAlarm = SysParam.Pd_param.s_Alarm.DoseRatePreAlarm;
 1283   1          ModBusPD_Param.s_Alarm.DoseRateAlarm= SysParam.Pd_param.s_Alarm.DoseRateAlarm;
 1284   1          ModBusPD_Param.s_Alarm.DosePreAlarm = SysParam.Pd_param.s_Alarm.DosePreAlarm;
 1285   1          ModBusPD_Param.s_Alarm.DoseAlarm = SysParam.Pd_param.s_Alarm.DoseAlarm;
 1286   1      
 1287   1          memset(&ModBusPD_Param.s_Thr, 0, sizeof(PD_THR));
 1288   1          for(i = 0;i<3;i++)
 1289   1          {
 1290   2              ModBusPD_Param.s_Thr.Det_Thr[i] = SysParam.Pd_param.s_Thr.Det_Thr[i];
 1291   2          }
 1292   1          ModBusPD_Param.s_Thr.AnalogChannel = SysParam.Pd_param.s_Thr.AnalogChannel;
 1293   1      
 1294   1          memset(&ModBusPD_Param.fix, 0, sizeof(ModBusPD_Param.fix));
 1295   1          for(i = 0;i < 17;i++)
 1296   1          {
 1297   2              ModBusPD_Param.fix[i] = SysParam.Pd_param.fix[i];
 1298   2          }
 1299   1      
 1300   1          //memset(&ModBusPD_Param.s_PdInfo, 0, sizeof(PD_INFO));
 1301   1              
 1302   1          //memcpy(SysParam.Pd_param.s_PdInfo.Name,SysParam.s_General_Info.Name,32);
 1303   1          //memcpy(ModBusPD_Param.s_PdInfo.Index,SysParam.Pd_param.s_PdInfo.Index,32);
 1304   1          //memcpy(ModBusPD_Param.s_PdInfo.Location,SysParam.Pd_param.s_PdInfo.Location,32);
 1305   1          //memcpy(ModBusPD_Param.s_PdInfo.Name,SysParam.Pd_param.s_PdInfo.Name,32);
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 21  

 1306   1          
 1307   1      }
 1308          
 1309          void Dev_Init()
 1310          {
 1311   1          ProbeSwitch = 0;
 1312   1          if((D1()&&D2()))
 1313   1          {
 1314   2              ProbeSwitch = 0;
 1315   2          }
 1316   1          else
 1317   1          {
 1318   2              if(!D1())
 1319   2              {
 1320   3                  ProbeSwitch = 1;
 1321   3              }
 1322   2              else if(!D2())
 1323   2              {
 1324   3                  ProbeSwitch = 2;
 1325   3              }
 1326   2          }
 1327   1          //ProbeSwitch_State = ProbeSwitch;
 1328   1          RST(0);
 1329   1          ES0_M(0);
 1330   1          //ES1_M(0);
 1331   1      
 1332   1      }
 1333          
 1334          void main(void)
 1335          {
 1336   1          SysInit();
 1337   1          IoInit();
 1338   1          PW_MAIN(1);  // 主电源
 1339   1          delay_ms(500);
 1340   1          
 1341   1          RUN_LED(1);
 1342   1          
 1343   1          //ProbeSelect();
 1344   1          Dev_Init(); 
 1345   1          LX_MP3_Init();
 1346   1          LedInit();
 1347   1          delay_ms(500);
 1348   1          
 1349   1          Timer0_Init();
 1350   1          Timer1_Init();
 1351   1          Timer3_Init();
 1352   1          Timer4_Init();
 1353   1          delay_ms(500);
 1354   1      
 1355   1          UART1_config();
 1356   1          UART2_config();
 1357   1          UART3_config();
 1358   1          UART4_config();
 1359   1          ClearUart1Buf();
 1360   1          ClearUart2Buf();
 1361   1          ClearUart3Buf();
 1362   1          ClearUart4Buf();
 1363   1          // 待CPU稳定了再读参数
 1364   1          delay_ms(500);
 1365   1          ReadParam();
 1366   1          delay_ms(500);
 1367   1      
 1368   1          RUN_LED(0);
 1369   1      
 1370   1          EA = 1;     //打开总中断
 1371   1          SensorInit();
C251 COMPILER V5.60.0,  main                                                               28/02/25  09:05:17  PAGE 22  

 1372   1          delay_ms(500);
 1373   1          InitLcd();
 1374   1          delay_ms(500);
 1375   1      //    ETH_Init();
 1376   1      //    delay_ms(500);
 1377   1          ClearCounter();
 1378   1          if(ProbeSwitch != 2)
 1379   1          {
 1380   2              MCP4725_OutVol(MCP4725_S1_ADDR,(char *)SysParam.Lp_Param.s_SysParam.yuzhi1);
 1381   2          }
 1382   1          WDT_CONTR |= (1<<5) |  7;  // 启动开门狗，约8秒
 1383   1          while(1)
 1384   1          {
 1385   2              TimerTask(); 
 1386   2              GetInput();
 1387   2              if(SysRunState.isCanReadSensor == 1)
 1388   2              {
 1389   3                  SysRunState.isCanReadSensor = 0;
 1390   3                  if(ProbeSwitch != 2)
 1391   3                  {
 1392   4                      CaptureSensorPluseCounter();//捕获当前测量结果
 1393   4                  }
 1394   3              }
 1395   2      
 1396   2              Uart1Hnd();
 1397   2              Uart2Hnd();
 1398   2              Uart3Hnd(); 
 1399   2              Uart4Hnd();
 1400   2          }
 1401   1      }
 1402          
 1403          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5850     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       468     ------
  xdata-const size     =    ------     ------
  edata size           =       346     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       847     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
