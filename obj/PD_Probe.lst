C251 COMPILER V5.60.0,  PD_Probe                                                           28/02/25  09:05:18  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE PD_Probe
OBJECT MODULE PLACED IN .\obj\PD_Probe.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE Probe\PD_Probe.c XSMALL OPTIMIZE(0,SPEED) BROWSE INCDIR(.\Ads1110;.\Fl
                    -ash;.\mcp4725;.\IIC;.\MwPro;.\Uart;.\Lcd;.\ModBus;.\Probe;.\BSP;.\MwPro) PRINT(.\obj\PD_Probe.lst) OBJECT(.\obj\PD_Probe
                    -.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include "ModBusHost.h"
    3          #include "ModBusDev.h"
    4          #include "PD_Probe.h"
    5          #include "ModBus.h"
    6          
    7          extern HOST_SEND_FRAME xdata  HostSendFrame;   // 发送帧
    8          extern DEVICE_READ_ACK xdata  ReadAckFrame;    // 读接收帧
    9          extern DEVICE_WRITE_ACK xdata WriteAckFrame;  // 写接收帧
   10          extern MODBUS_PD_PARAM xdata ModBusPD_Param;
   11          
   12          extern SYS_PARAM xdata SysParam;
   13          extern PROBE_REGADDR xdata ProbeRegAddr;
   14          extern float My_PDDoserate;
   15          
   16          
   17          
   18          // Count :  寄存器个数
   19          void SendReadPD(void)
   20          {
   21   1          WORD RegCnt = 12;
   22   1          HostSendCmd(RS485, (BYTE)SysParam.Pd_param.Address,CMD_READ_REG, MODBUS_DOSERATE_ADD, RegCnt, NULL);
   23   1      }
   24          
   25          void SendReadPD_DoseRate(void)
   26          {
   27   1          WORD RegCnt = 12;
   28   1          HostSendCmd(RS485, (BYTE)SysParam.Pd_param.Address,CMD_READ_REG, MODBUS_DOSERATE_ADD, RegCnt, NULL);
   29   1      }
   30          void SendReadPD_Alarm(void)
   31          {
   32   1          WORD RegCnt = 8;
   33   1          HostSendCmd(RS485, (BYTE)SysParam.Pd_param.Address,CMD_READ_REG, MODBUS_ALARM_ADD, RegCnt, NULL);
   34   1      }
   35          void SendReadPD_Thr(void)
   36          {
   37   1          WORD RegCnt = 4;
   38   1          HostSendCmd(RS485, (BYTE)SysParam.Pd_param.Address,CMD_READ_REG, MODBUS_THR_ADD, RegCnt, NULL);
   39   1      }
   40          void SendReadPD_fix(void)
   41          {
   42   1          WORD RegCnt = 34;
   43   1          HostSendCmd(RS485, (BYTE)SysParam.Pd_param.Address,CMD_READ_REG, MODBUS_FACTOR_ADD, RegCnt, NULL);
   44   1      }
   45          void SendReadPD_Info(void)
   46          {
   47   1          WORD RegCnt = 48;
   48   1          HostSendCmd(RS485, (BYTE)SysParam.Pd_param.Address,CMD_READ_REG, MODBUS_DEV_INFO, RegCnt, NULL);
   49   1      }
   50          void SendReadPD_Address(void)
   51          {
   52   1          WORD RegCnt = 1;
   53   1          HostSendCmd(RS485, (BYTE)SysParam.Pd_param.Address,CMD_READ_REG, MODBUS_DEV_ADD, RegCnt, NULL);
   54   1      }
   55          void SendReadPD_Ver(void)
   56          {
   57   1          WORD RegCnt = 1;
C251 COMPILER V5.60.0,  PD_Probe                                                           28/02/25  09:05:18  PAGE 2   

   58   1          HostSendCmd(RS485, (BYTE)SysParam.Pd_param.Address,CMD_READ_REG, MODBUS_DEV_VER, RegCnt, NULL);
   59   1      }
   60          
   61          void WritePD_Alarm()
   62          {
   63   1          WORD RegCnt = 8;
   64   1          SyncModBusDev();
   65   1          HostSendCmd(RS485,1, CMD_WRITE_REG, MODBUS_ALARM_ADD, RegCnt, (BYTE *)&ModBusPD_Param.s_Alarm);
   66   1      }
   67          
   68          void WritePD_Thr()
   69          {
   70   1          WORD RegCnt = 4;
   71   1          SyncModBusDev();
   72   1          HostSendCmd(RS485,1, CMD_WRITE_REG, MODBUS_THR_ADD, RegCnt, (BYTE *)&ModBusPD_Param.s_Thr);
   73   1      }
   74          
   75          void WritePD_fix()
   76          {
   77   1          WORD RegCnt = 34;
   78   1          SyncModBusDev();
   79   1          HostSendCmd(RS485,1, CMD_WRITE_REG, MODBUS_FACTOR_ADD, RegCnt, (BYTE *)&ModBusPD_Param.fix);
   80   1      }
   81          
   82          void WritePD_Info()
   83          {
   84   1          WORD RegCnt = 48;
   85   1          SyncModBusDev();
   86   1          HostSendCmd(RS485,1, CMD_WRITE_REG, MODBUS_DEV_INFO, RegCnt, (BYTE *)&ModBusPD_Param.s_PdInfo);
   87   1      }
   88          
   89          void WritePD_Address()
   90          {
   91   1          WORD RegCnt = 1;
   92   1          SyncModBusDev();
   93   1          HostSendCmd(RS485,1, CMD_WRITE_REG, MODBUS_DEV_ADD, RegCnt, (BYTE *)&ModBusPD_Param.Address);
   94   1      }
   95          
   96          
   97          void ModBusPDSave()
   98          {
   99   1          BYTE i = 0;
  100   1          SysParam.Pd_param.s_DoseRate.DoseRate = ModBusPD_Param.s_DoseRate.DoseRate;
  101   1          SysParam.Pd_param.s_DoseRate.DoseTotal = ModBusPD_Param.s_DoseRate.DoseTotal;
  102   1          SysParam.Pd_param.s_DoseRate.Cps1 = ModBusPD_Param.s_DoseRate.Cps1;
  103   1          SysParam.Pd_param.s_DoseRate.Cps2 = ModBusPD_Param.s_DoseRate.Cps2;
  104   1          SysParam.Pd_param.s_DoseRate.Cps3 = ModBusPD_Param.s_DoseRate.Cps3;
  105   1          //SysParam.Pd_param.s_DoseRate.DevSt = ModBusPD_Param.s_DoseRate.DevSt;
  106   1          //SysParam.Pd_param.Address = ModBusPD_Param.Address; 
  107   1          for(i = 0;i<3;i++)
  108   1          {
  109   2              SysParam.Pd_param.s_Thr.Det_Thr[i] = ModBusPD_Param.s_Thr.Det_Thr[i];
  110   2          }
  111   1          //SysParam.Pd_param.s_Thr.AnalogChannel = ModBusPD_Param.s_Thr.AnalogChannel;
  112   1          for(i = 0;i<17;i++)
  113   1          {
  114   2              SysParam.Pd_param.fix[i] = ModBusPD_Param.fix[i];
  115   2          }
  116   1      
  117   1          #if 0
                   memcpy(SysParam.Pd_param.s_PdInfo.Index,ModBusPD_Param.s_PdInfo.Index,32);
                   memcpy(SysParam.Pd_param.s_PdInfo.Location,ModBusPD_Param.s_PdInfo.Location,32);
                   memcpy(SysParam.Pd_param.s_PdInfo.Name,ModBusPD_Param.s_PdInfo.Name,32);    
                   SysParam.Pd_param.Ver = ModBusPD_Param.Ver; 
                   SysParam.Pd_param.s_Alarm.DoseRatePreAlarm = ModBusPD_Param.s_Alarm.DoseRatePreAlarm;
                   SysParam.Pd_param.s_Alarm.DoseRateAlarm = ModBusPD_Param.s_Alarm.DoseRateAlarm;
C251 COMPILER V5.60.0,  PD_Probe                                                           28/02/25  09:05:18  PAGE 3   

                   SysParam.Pd_param.s_Alarm.DosePreAlarm = ModBusPD_Param.s_Alarm.DosePreAlarm;
                   SysParam.Pd_param.s_Alarm.DoseAlarm = ModBusPD_Param.s_Alarm.DoseAlarm;
               
                   #endif
  128   1          
  129   1          WriteParam();
  130   1      }
  131          
  132          bool WritePD_Ack()
  133          {
  134   1         return true;
  135   1      }
  136          
  137          bool Calc_PD_AlarmState()
  138          {
  139   1          static u16 DrAlarmCnt = 0;
  140   1          static u16 DrPreAlarmCnt = 0;
  141   1              SysParam.Pd_param.s_DoseRate.DevSt = 0;
  142   1          #if 0
                   /* 剂量当量报警检查 */    
                   if ((SysParam.Pd_param.s_DoseRate.DoseTotal >= SysParam.Pd_param.s_Alarm.DoseAlarm)
                       &&(SysParam.Pd_param.s_Alarm.DoseAlarm > 0)) 
                   { 
                       SysParam.Pd_param.s_DoseRate.DevSt |= DOSE_ALARM_BIT;
                   } 
                   else
                   {
                       SysParam.Pd_param.s_DoseRate.DevSt &= ~DOSE_ALARM_BIT;
                   }
                   
                   /* 剂量当量预警检查 */    
                   if( (SysParam.Pd_param.s_DoseRate.DoseTotal >= SysParam.Pd_param.s_Alarm.DosePreAlarm)
                       &&(SysParam.Pd_param.s_Alarm.DosePreAlarm > 0)
                       &&(SysParam.Pd_param.s_DoseRate.DoseTotal < SysParam.Pd_param.s_Alarm.DoseAlarm) ) 
                   { 
                       SysParam.Pd_param.s_DoseRate.DevSt |= DOSE_PRE_ALARM_BIT;
                   } 
                   else
                   {
                       SysParam.Pd_param.s_DoseRate.DevSt &= ~DOSE_PRE_ALARM_BIT;
                   }
                   #endif    
  166   1          
  167   1          /* 剂量当量率报警检查*/    
  168   1          if ( (SysParam.Pd_param.s_DoseRate.DoseRate >= SysParam.Pd_param.s_Alarm.DoseRateAlarm)
  169   1              &&(SysParam.Pd_param.s_Alarm.DoseRateAlarm > 0) ) 
  170   1          { 
  171   2              if((++DrAlarmCnt) >= MIB_CST_DOSERATE_THRESHOLD_ALARM) 
  172   2              {   
  173   3                  //连续两次报警则认为报警
  174   3                 SysParam.Pd_param.s_DoseRate.DevSt |= DOSERATE_ALARM_BIT;
  175   3              }
  176   2          } 
  177   1          else 
  178   1          {
  179   2              DrAlarmCnt= 0x0;
  180   2              SysParam.Pd_param.s_DoseRate.DevSt &= ~DOSERATE_ALARM_BIT;
  181   2          }
  182   1          
  183   1          /* 剂量当量率预警检查 */    
  184   1          if ( (SysParam.Pd_param.s_DoseRate.DoseRate >= SysParam.Pd_param.s_Alarm.DoseRatePreAlarm)
  185   1              &&(SysParam.Pd_param.s_DoseRate.DoseRate < SysParam.Pd_param.s_Alarm.DoseRateAlarm) )
  186   1          { 
  187   2              if((++DrPreAlarmCnt) >= MIB_CST_DOSERATE_THRESHOLD_WARNING) 
  188   2              {
  189   3                  //连续两次报警则认为报警
C251 COMPILER V5.60.0,  PD_Probe                                                           28/02/25  09:05:18  PAGE 4   

  190   3                  SysParam.Pd_param.s_DoseRate.DevSt |= DOSERATE_PRE_ALARM_BIT;
  191   3              }
  192   2          } 
  193   1          else 
  194   1          {
  195   2              DrPreAlarmCnt= 0x0;
  196   2              SysParam.Pd_param.s_DoseRate.DevSt &= ~DOSERATE_PRE_ALARM_BIT;
  197   2          }
  198   1      
  199   1          #if 0
                   if (SysParam.Pd_param.s_DoseRate.DoseTotal >= 10.0*1000*1000)
                   {
                       SysParam.Pd_param.s_DoseRate.DevSt |= OVER_RANGE_BIT;
                       SysParam.Pd_param.s_DoseRate.DoseTotal = 10.0*1000*1000;
                   }
                   else
                   {
                       SysParam.Pd_param.s_DoseRate.DevSt &= ~OVER_RANGE_BIT;
                   }
                   #endif
  210   1          return true;
  211   1      }
  212          
  213          
  214          
  215          void Set_PD_DoseRateUnit()
  216          {
  217   1          if(My_PDDoserate < 1000)
  218   1          {
  219   2                if(My_PDDoserate < 100)
  220   2              {
  221   3                  RunStatus.Unit = Unit_uSv;
  222   3              }
  223   2              else
  224   2              {
  225   3                  RunStatus.Unit = Unit_mSv;
  226   3                  My_PDDoserate = My_PDDoserate / 1000;
  227   3              }
  228   2          }
  229   1          else if(My_PDDoserate < 1000000)
  230   1          {
  231   2              My_PDDoserate= My_PDDoserate / 1000;
  232   2              if(My_PDDoserate < 100)
  233   2              {
  234   3                  RunStatus.Unit = Unit_mSv;
  235   3              }
  236   2              else
  237   2              {
  238   3                  RunStatus.Unit = Unit_Sv;
  239   3                  My_PDDoserate = My_PDDoserate / 1000;
  240   3              }
  241   2          }
  242   1          else
  243   1          {
  244   2              RunStatus.Unit = Unit_Sv;
  245   2              if(My_PDDoserate > 100000000)
  246   2              {
  247   3                  My_PDDoserate = 100000000;
  248   3              }
  249   2              My_PDDoserate = My_PDDoserate / 1000000;
  250   2          }
  251   1      }
  252          
  253          
  254          
  255          BYTE ReadPD_Ack()
C251 COMPILER V5.60.0,  PD_Probe                                                           28/02/25  09:05:18  PAGE 5   

  256          {
  257   1          WORD i = 0;
  258   1          WORD dat = 0;   
  259   1          if(ReadAckFrame.DataLen <= 0)
  260   1          {
  261   2              return false;
  262   2          }
  263   1         #if 0
                   if(ReadAckFrame.DataLen == 2)
                   { 
                       memcpy(&dat, ReadAckFrame.Data, 2);
                       if(dat >= 100)
                       {
                           memcpy(&ModBusPD_Param.Ver, ReadAckFrame.Data, 2);
                       }
                       else
                       {
                           memcpy(&ModBusPD_Param.Address, ReadAckFrame.Data, 2);
                       }
                   } 
                   
                   else if(ReadAckFrame.DataLen == sizeof(PD_INFO))
                   {
                       memcpy(&ModBusPD_Param.s_PdInfo, ReadAckFrame.Data,sizeof(PD_INFO));
                   } 
                   #endif
  282   1          else if(ReadAckFrame.DataLen == sizeof(ModBusPD_Param.fix))
  283   1          {
  284   2              memcpy(&ModBusPD_Param.fix, ReadAckFrame.Data,sizeof(ModBusPD_Param.fix));
  285   2          }
  286   1          else if(ReadAckFrame.DataLen == sizeof(PD_THR))
  287   1          {
  288   2              memcpy(&ModBusPD_Param.s_Thr, ReadAckFrame.Data,sizeof(PD_THR));
  289   2          }
  290   1          else if(ReadAckFrame.DataLen == sizeof(PD_ALARM))
  291   1          {
  292   2              memcpy(&ModBusPD_Param.s_Alarm, ReadAckFrame.Data,sizeof(PD_ALARM));
  293   2          }
  294   1        
  295   1          if(ReadAckFrame.DataLen == sizeof(PD_DOSERATE))
  296   1          {
  297   2              memcpy(&ModBusPD_Param.s_DoseRate, ReadAckFrame.Data,sizeof(PD_DOSERATE));
  298   2          }
  299   1          ModBusPDSave();
  300   1          return true;
  301   1      }
  302          
  303          
  304          void PDProbe_Ack(BYTE *Buf, BYTE Len)
  305          {
  306   1          if (!ValidRtuFrame(Buf, Len))
  307   1          {
  308   2              //DebugMsg("Comm err\r\n",10);
  309   2              return;
  310   2          }
  311   1      
  312   1          memset(&ReadAckFrame, 0, sizeof(DEVICE_READ_ACK));
  313   1          memcpy(&ReadAckFrame, Buf, Len);
  314   1         
  315   1         if(ReadAckFrame.Address != SysParam.Pd_param.Address)
  316   1          {
  317   2              return;
  318   2          }
  319   1          switch(ReadAckFrame.FunctionCode)
  320   1          {      
  321   2              case CMD_READ_REG: 
C251 COMPILER V5.60.0,  PD_Probe                                                           28/02/25  09:05:18  PAGE 6   

  322   2              {
  323   3                  ReadPD_Ack(); 
  324   3                  Calc_PD_AlarmState();
  325   3                  My_PDDoserate = SysParam.Pd_param.s_DoseRate.DoseRate;
  326   3                  Set_PD_DoseRateUnit();
  327   3                  break;
  328   3              }
  329   2              case CMD_WRITE_REG:  WritePD_Ack() ;  break;
  330   2          }
  331   1      }
  332          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1549     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        40     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        12     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
